/*
 * Copyright 2017 The Tsinghua University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tsinghua.stargate.rpc.thrift;

import static org.apache.thrift.server.TThreadedSelectorServer.Args.AcceptPolicy.FAST_ACCEPT;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.net.InetSocketAddress;
import java.util.concurrent.TimeUnit;

import javax.net.SocketFactory;

import org.apache.thrift.TProcessor;
import org.apache.thrift.protocol.TCompactProtocol;
import org.apache.thrift.server.TServer;
import org.apache.thrift.server.TThreadedSelectorServer;
import org.apache.thrift.server.TThreadedSelectorServer.Args.AcceptPolicy;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TNonblockingServerSocket;
import org.apache.thrift.transport.TNonblockingServerTransport;
import org.apache.thrift.transport.TTransportException;

import tsinghua.stargate.conf.Configuration;
import tsinghua.stargate.conf.NameSpace;
import tsinghua.stargate.exception.StarGateException;
import tsinghua.stargate.exception.StarGateRuntimeException;
import tsinghua.stargate.io.RpcIO;
import tsinghua.stargate.rpc.RpcEngine;
import tsinghua.stargate.rpc.thrift.ApplicationStarGateProtocolService.Iface;
import tsinghua.stargate.rpc.workhorse.*;

/** A RPC engine for handling the protocols implemented by Thrift. */
public class ThriftRpcEngine implements RpcEngine {

  private static final RpcClientCache CLIENT_CACHE = new RpcClientCache();

  /**
   * Employ Java dynamic proxy to do RPC.
   *
   * @param protocol a Java interface used for exchanging information between
   *          RPC client (i.e. <code>Client</code>) and RPC tServer (i.e.
   *          <code>StarGateDaemon</code>)
   * @param clientVersion the current version of client
   * @param address the <code>StarGateDaemon</code> location
   * @param conf a configuration profiler
   * @param factory the factory for creating sockets
   * @param rpcTimeout timeout value for each RPC, 0 means no timeout
   * @param <T> protocol type
   * @return a <code>ProtocolProxy</code> instance
   * @throws IOException if some I/O errors occur
   */
  @Override
  @SuppressWarnings("unchecked")
  public <T> ProtocolProxy<T> getProxy(Class<T> protocol, long clientVersion,
      InetSocketAddress address, Configuration conf, SocketFactory factory,
      int rpcTimeout) throws IOException {
    final RpcDynamicProxyHandlerImpl invocationHandler =
        new RpcDynamicProxyHandlerImpl(protocol, address, conf, factory,
            rpcTimeout);
    return new ProtocolProxy<>(protocol,
        (T) Proxy.newProxyInstance(protocol.getClassLoader(),
            new Class[] { protocol }, invocationHandler));
  }

  /**
   * Construct a RPC Server proxy.
   *
   * @param conf configuration profiler
   * @param address tServer socket address for binding
   * @param ioQueueSize queue size for per IO thread
   * @param ioThreads number of IO threads
   * @param workerThreads number of worker threads
   * @param protocol protocol that is auto generated by a specific RPC engine
   * @param processor processor for handling {@code protocol} that is auto
   *          generated by a specific RPC engine
   * @return a RPC Server proxy
   */
  @Override
  public RpcServer getServer(Configuration conf, InetSocketAddress address,
      int ioQueueSize, int ioThreads, int workerThreads, Class<?> protocol,
      Object processor) {
    return new ThriftServer(conf, address, ioQueueSize, ioThreads,
        workerThreads, protocol, processor);
  }

  /** A dynamic proxy implementation for handling method invoking requests. */
  private static class RpcDynamicProxyHandlerImpl
      implements RpcDynamicProxyHandler {

    final RpcClient client;
    private final String protocolName;
    private final RpcClient.ConnectionId connectionId;
    private boolean isClosed = false;

    private RpcDynamicProxyHandlerImpl(Class<?> protocol,
        InetSocketAddress address, Configuration conf,
        SocketFactory socketFactory, int rpcTimeout) throws IOException {
      this(protocol, RpcClient.ConnectionId.getConnectionId(protocol, address,
          conf, rpcTimeout), conf, socketFactory);
    }

    private RpcDynamicProxyHandlerImpl(Class<?> protocol,
        RpcClient.ConnectionId connectionId, Configuration conf,
        SocketFactory socketFactory) {
      this.client =
          CLIENT_CACHE.getClient(conf, socketFactory, RpcResponseThrift.class);
      this.protocolName = RpcManager.getProtocolName(protocol);
      this.connectionId = connectionId;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
        throws StarGateException {
      if (args.length != 1) { // RPC request message
        throw new StarGateException("Too many parameters for request. Method: ["
            + method.getName() + "]" + ", Expected: 1, Actual: " + args.length);
      }
      if (args[0] == null) { // Without Message
        throw new StarGateException(
            "Null param while calling Method: [" + method.getName() + "]");
      }

      Object rpcRequest = args[0];
      RpcResponseThrift rpcResponseThrift = null;
      try {
        rpcResponseThrift =
            (RpcResponseThrift) client.call(RpcManager.RpcType.RPC_THRIFT,
                new RpcRequestThrift(method, rpcRequest), connectionId);
      } catch (Throwable e) {

      }

      return rpcResponseThrift.sendingResponse;
    }

    @Override
    public RpcClient.ConnectionId getConnectionId() {
      return connectionId;
    }

    @Override
    public void close() {
      if (!isClosed) {
        isClosed = true;
        CLIENT_CACHE.stopClient(client);

        System.out.println("stop client");
      }
    }
  }

  public static class ThriftServer extends RpcServer {

    private int maxFrameLength;
    private AcceptPolicy acceptPolicy;
    private int stopTimeoutVal;
    private TimeUnit stopTimeoutUnit;

    // TODO: must use synchronization?
    private TServer tServer;

    ThriftServer(Configuration conf, InetSocketAddress bindAddress,
        int ioQueueSize, int ioThreads, int workerThreads, Class<?> protocol,
        Object processor) {
      super(bindAddress, ioQueueSize, ioThreads, workerThreads);

      this.maxFrameLength =
          (int) conf.getLong(NameSpace.RPC_THRIFT_FRAME_LENGTH_MAX,
              NameSpace.DEFAULT_RPC_THRIFT_FRAME_LENGTH_MAX);
      this.acceptPolicy = FAST_ACCEPT;
      this.stopTimeoutVal = 60;
      this.stopTimeoutUnit = TimeUnit.SECONDS;

      // Create a nonblocking transport
      TNonblockingServerTransport transport;
      try {
        transport = new TNonblockingServerSocket(bindAddress);
      } catch (TTransportException e) {
        throw new StarGateRuntimeException(e);
      }

      // Create a multiplexed processor
      // TMultiplexedProcessor mp = new TMultiplexedProcessor();
      // if (!(processor instanceof TProcessor)) {
      // error("The given processor doesn't implement TProcessor");
      // return;
      // } else {
      // mp.registerProcessor(protocol.getSimpleName(), (TProcessor) processor);
      // }

      // Configure and create a nonblocking tServer
      TThreadedSelectorServer.Args args =
          new TThreadedSelectorServer.Args(transport)
              .transportFactory(new TFramedTransport.Factory(maxFrameLength))
              .protocolFactory(new TCompactProtocol.Factory())
              .processor((TProcessor) processor).acceptPolicy(acceptPolicy)
              .acceptQueueSizePerThread(ioQueueSize).selectorThreads(ioThreads)
              .workerThreads(workerThreads).stopTimeoutVal(stopTimeoutVal)
              .stopTimeoutUnit(stopTimeoutUnit);
      tServer = new TThreadedSelectorServer(args);
    }

    @Override
    protected void serve() {
      info("Starting Thrift Server '{}'", tServer.getClass().getSimpleName());
      tServer.serve();
    }

    @Override
    public void stopImpl() {
      tServer.stop();
      info("Successfully stopped '{}'", tServer.getClass().getSimpleName());
    }
  }

  // TODO: Iface multi class has
  public static class RpcRequestThrift implements RpcIO<Iface, Iface> {

    private final Method method;
    private final Object sendingMsg;

    private RpcClient.Call call;

    public RpcRequestThrift(Method method, Object request) {
      this.method = method;
      this.sendingMsg = request;
    }

    @Override
    public void read(Iface client) throws IOException {

    }

    @Override
    public void write(Iface client) throws IOException {
      try {
        method.setAccessible(true);
        Object callResult = method.invoke(client, sendingMsg);
        RpcClient.Call call = getCall();
        call.setRpcResponse(new RpcResponseThrift(callResult));
      } catch (IllegalAccessException e) {
        throw new IOException(e.getMessage(), e.getCause());
      } catch (InvocationTargetException e) {
        e.printStackTrace();
        throw new IOException(e.getMessage(), e.getCause());
      }
    }

    @Override
    public int size() {
      return 1;
    }

    public RpcClient.Call getCall() {
      return call;
    }

    public void setCall(RpcClient.Call call) {
      this.call = call;
    }
  }

  /** Wrapper for Thrift Responses. */
  public static class RpcResponseThrift implements RpcIO<Iface, Iface> {

    Object sendingResponse; // Object for storing the message

    public RpcResponseThrift(Object msg) {
      this.sendingResponse = msg;
    }

    @Override
    public void read(Iface client) {

    }

    @Override
    public void write(Iface client) {

    }

    @Override
    public int size() {
      return 1;
    }
  }
}
